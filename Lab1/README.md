# Лабораторная работа №1 

### Исходные данные
• Цифровое изображение
• Алгоритм внесения искажений

### Общий план выполнения работы
1. Разработать клиент серверный механизм передачи цифрового изображения.
2. Учесть возможность возникновения помех в канале передачи.
3. Разработать блок восстановления полученных изображений на стороне сервера.
4. Для передачи данных между клиентом и сервером использовать сокеты Беркли.
5. Оценить потери данных при наличии блока восстановления ошибок и при его
отсутствии.

#### Описание программы
Программа состоит из трёх модулей:

Client - отвечает за отправку исходного изображения.

Noise_Server - промежуточный сервер, который принимает оригинальное изображение, добавляет к нему импульсный шум, и отправляет конечному серверу.

Server - принимает изображение с шумом и чистит его, а затем оцениват потери путем сравнения исходного изображения в с зашумлённым и с очищенным.

Передача между модулями осуществляется с помощью сокетов Беркли. Отдельно было прописано два метода: для внесения импульного шума (add_noise) и реализация медианного фильтра для его устранения (m_filter), в отличие от встроенного он меньше размывает изображение.

Для оценки потери данных считается стандартное отклонение и вычисляется процент незатронутых пикселей, где пиксель считается незатронутым, если его значение изменилось менее чем на 20.

### Результаты
Ниже приведена таблица времени работы параллельной и последовательной функций для различных размерностей матрицы. Время указано в миллисекундах и получено как среднее по 5 запускам.

Размерность матриц, N | Время работы на GPU, мс | Время работы на CPU, мс | Ускорение
:----:|:-------:|:-----------:|------:
128 | 0,15 | 8,52 | 56,80
256 | 0,63| 92,13 | 146,23
512 | 3,83 | 878,00 | 229,24
1024 | 26,06 | 16234,77 | 622,97
2048 | 190.51 | 181225,90 | 951,26

### Визуализация таблицы.
##### График времени рассчёта произведения матриц

![](Work_time.JPG)

##### График ускорения

![](Speedup.JPG)

На основе полученных результатов можно сделать вывод, что время работы функции выполняющейся на GPU растёт очень медленно при увеличении размерности матрицы, чего нельзя сказать о функции перемножения на CPU. По графику ускорения видно, что программа на CUDA дает существенный выигрыш во времени при решении задачи по переемножению матриц. 
